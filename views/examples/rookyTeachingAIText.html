In implementations of game AI's for zero-sum games such as chess, the computer is actually quite dumb. In order to determine which moves are 'good,' the program scans through every possible, legal move. Using a hardcoded scoring system, each move is assigned a net score which can be compared with all of the other moves.<br><br>The AI then must have the ability to see several moves into the future, or it may capture a pawn with a queen, only to have its queen captured next turn. A efficient chess program written in something like C should be able to scan several million moves in one second. That means the AI is actually seeing six to seven moves into the future, recursively judging which immediate move will lead to the greatest net gain in score.<br><br>
<pre>
  def moveScan(x0, y0, dx, dy, stopShort, capture, aState)
  # This method is called many times by the moveList method,
  # which passes in every combination of movement directions for
  # a given piece for a given square position.
    x = x0
    y = y0
    c = colorOf(x,y, aState)
    moves     = []
    validMove = []
    loop do
      x += dx
      y += dy
      break if not inBounds?(x, y)
      if aState[y][x].to_s != '.'
        break if colorOf(x, y, aState) == c  # Same color, so the move is invalid
        if capture == false
          break                              # We don't want to take this capture
        else
          stopShort = true                   # the capture move is valid
        end
      end
      validMove = Move.new(Square.new(x0, y0), Square.new(x, y))
      moves &lt&lt validMove
      break if stopShort == true
    end
    return moves if moves != []
  end
</pre>
