A game of minichess is played on a five-by-six rectangular board. The AI must always possess a representation of the location of each of the pieces on the board, as well as each of the empty spaces. This data must be synced after the moves of either player, accounting for piece movement and captured pieces.<br><br>The most efficient way to represent all of this data in memory is with constructs known as bitboards. A bitboard, in the case of minichess, is a 30 bit integer, where each bit represents a position on the board. Many bitboards are needed to maintain data on various things, such as the location of the white knight, or of the black pawns. As piece movement occurs, bitwise operations are applied to the appropriate bitboards to change their contents.<br><br>In my board implementation, I did not utilize bitboards. Instead, I created a simple 2D array to represent the board, with ASCii characters represented each square's current state. I did this primarily because of the difficulty in implementing bitboards, as well as course time constraints.<br><br>
<pre>
  def newBoard
  # Reset all piece locations to create fresh board

    @onMove          = 'W'
    @onMoveInt       = 1
    @turnCount       = 0
    @whiteKingSym    = 'K'
    @whiteQueenSym   = 'Q'
    @whiteBishopSym  = 'B'
    @whiteKnightSym  = 'N'
    @whiteRookSym    = 'R'
    @whitePawnSym    = 'P'

    @blackKingSym    = 'k'
    @blackQueenSym   = 'q'
    @blackBishopSym  = 'b'
    @blackKnightSym  = 'n'
    @blackRookSym    = 'r'
    @blackPawnSym    = 'p'
    @board = [
      ['R', 'N', 'B', 'Q', 'K'],
      ['P', 'P', 'P', 'P', 'P'],
      ['.', '.', '.', '.', '.'],
      ['.', '.', '.', '.', '.'],
      ['p', 'p', 'p', 'p', 'p'],
      ['k', 'q', 'b', 'n', 'r']
    ]
  end
</pre>
